<?php
//20.0.56.0 FMK/Hash.php GF 
//VersionVI: 30F200066p
//(c) 2005-2012 PC SOFT  - Release
 if (!defined('__INC__FMK/Dependance.php')) { define('__INC__FMK/Dependance.php',true); include_once(WB_INCLUDE_PATH.'WDb98029e1a3f05e7ed504ba0a18a9dea8.php'); } define('FMK_HASH_EXTENSION_AUCUNE',0); define('FMK_HASH_EXTENSION_NATIVE_PHP5',1); define('FMK_HASH_EXTENSION_MHASH',2); define('FMK_CRYPT_EXTENSION_AUCUNE',0); define('FMK_CRYPT_EXTENSION_MCRYPT',1); define('PHPVERSION_HASH_TIGER_BUGENDIAN',(version_compare(PHP_VERSION,'5.4')===-1)); define('eHA_ALGO_'. 0x0000,'MD5'); define('eHA_ALGO_'. 0x0010,'SHA1'); define('eHA_ALGO_'. 0x0011,'SHA256'); define('eHA_ALGO_'. 0x0012,'SHA384'); define('eHA_ALGO_'. 0x0013,'SHA512'); define('eHA_ALGO_'. 0x0020,'RIPEMD128'); define('eHA_ALGO_'. 0x0021,'RIPEMD160'); define('eHA_ALGO_'. 0x0030,'TIGER128'); define('eHA_ALGO_'. 0x0031,'TIGER160'); define('eHA_ALGO_'. 0x0032,'TIGER192'); define('eHA_ALGO_'. 0x0040,'WHIRLPOOL'); define('eHA_ALGO_'. 0x0050,'CKSUM8'); define('eHA_ALGO_'. 0x0051,'CKSUM16'); define('eHA_ALGO_'. 0x0052,'CKSUM32'); define('eHA_ALGO_'. 0x0053,'CKSUM64'); define('eHA_ALGO_'. 0x0100,'MD5'); define('eHA_ALGO_'. 0x0110,'SHA1'); define('eHA_ALGO_'. 0x0111,'SHA256'); define('eHA_ALGO_'. 0x0112,'SHA384'); define('eHA_ALGO_'. 0x0113,'SHA512'); define('eHA_ALGO_'. 0x0120,'RIPEMD128'); define('eHA_ALGO_'. 0x0121,'RIPEMD160'); define('eHA_ALGO_'. 0x0130,'TIGER128'); define('eHA_ALGO_'. 0x0131,'TIGER160'); define('eHA_ALGO_'. 0x0132,'TIGER192'); define('eHA_ALGO_'. 0x0140,'WHIRLPOOL'); function Fa9c2e9dc($sHashHexa) { $sHash = ''; $nTaille = utf8_strlen($sHashHexa); for ($i=0; $i<=$nTaille-2; $i+=2) { $sHexa = utf8_substr($sHashHexa,$i,2); $sHash .= utf8_chr(hexdec($sHexa)); } unset($sHashHexa); unset($sHexa); return $sHash; } function F226190d9($sChaine, $nNbBits) { $nCKSUM = 0; if ($nNbBits == 64) { $bMode64 = true; $nNbBits = 32; } $nNbOctets = $nNbBits/8; unset($nNbBits); $i = -1; while (isset($sChaine[++$i])) { $nCKSUM+=utf8_ord($sChaine[$i]); } $sHash=utf8_str_pad('',$nNbOctets); for ($i = 0; $i<$nNbOctets; $i++) { $sHash[$i] = utf8_chr( ($nCKSUM & (0xFF<<$i*8)) >> ($i*8) ); } if (isset($bMode64)) { $sHash=utf8_str_pad($sHash,utf8_strlen($sHash)*2,utf8_chr(0)); } return $sHash; } function F5b75dd75($key, $data, $hash = 'md5', $blocksize = 64) { if (utf8_strlen($key)>$blocksize) { $key = pack('H*', $hash($key)); } $key = utf8_str_pad($key, $blocksize, utf8_chr(0)); $ipad = utf8_str_repeat(utf8_chr(0x36), $blocksize); $opad = utf8_str_repeat(utf8_chr(0x5c), $blocksize); return $hash(($key^$opad) . pack('H*', $hash(($key^$ipad) . $data))); } function F8d00e207($password) { $seed = utf8_substr('00' . dechex(mt_rand()), -3) . utf8_substr('00' . dechex(mt_rand()), -3) . utf8_substr('0' . dechex(mt_rand()), -2); return F5b75dd75($seed, $password, 'md5', 64) . $seed; } function F12399f62($password, $stored_value) { $seed = utf8_substr($stored_value, 32, 8); return F5b75dd75($seed, $password, 'md5', 64) . $seed==$stored_value; } class FMK_CRYPTHASH { var $m_bDependanceVerifiee; var $m_tabNomAlgo; var $m_pszErreur; function FMK_CRYPTHASH() { $this->m_bDependanceVerifiee = false; $this->m_tabNomAlgo = null; } function Fa9a6b21a() {return $this->m_pszErreur != '';} function F6a15f49c(&$pclErreur) {$this->m_pszErreur =& $pclErreur;} function Fcc87d15b() { } function F0c172f8b($nIdAlgo) { } function F4f7161e3($nIdAlgo,$sNomAlgo,$sChaine,$sClef=null) { } function Ff1e0c80b() { } function F0f610a15($sNomAlgo) { if (!$this->m_bDependanceVerifiee) { if (!$this->Fcc87d15b()) { return false; } else { $this->m_bDependanceVerifiee=true; } } return array_key_exists($sNomAlgo,$this->m_tabNomAlgo); } function Fb4468e0c($nIdAlgo,$sChaine,$sClef=null) { $sNomAlgo = $this->F63a136aa($nIdAlgo); if (!isset($sNomAlgo)||''===$sNomAlgo) { return false; } if (!$this->F0f610a15($sNomAlgo)) { $this->m_pszErreur = $this->Ff1e0c80b(); return false; } return $this->F4f7161e3($nIdAlgo,$sNomAlgo,$sChaine,$sClef); } } $_FMK_HASH = null; function& FMK_HASH() { global $_FMK_HASH; if (!isset($_FMK_HASH)) $_FMK_HASH = new FMK_HASH(); return $_FMK_HASH; } class FMK_HASH extends FMK_CRYPTHASH { function Ff1e0c80b() { return 'ERR_HASH_BAD_CONSTANT'; } function Fcc87d15b() { $this->m_tabNomAlgo = array(); $pclDependance =& FMK_Dependance(); if ($pclDependance->F0b5f8f06('mhash')) { $nMhashCount = mhash_count(); for ($i = 0; $i <= $nMhashCount; $i++) { $this->m_tabNomAlgo[mhash_get_hash_name($i)] = FMK_HASH_EXTENSION_MHASH; } } if (PHPVERSION_5 && function_exists('hash_algos')) { $tabAlgosHASH = hash_algos(); $tabAlgosHASH = array_map('strtoupper',$tabAlgosHASH); XASSERT(function_exists('array_combine')); $tabAlgosHASH = array_combine($tabAlgosHASH,array_fill(0,count($tabAlgosHASH),FMK_HASH_EXTENSION_NATIVE_PHP5)); $this->m_tabNomAlgo = array_merge($this->m_tabNomAlgo,$tabAlgosHASH); unset($tabAlgosHASH); } if (!isset($this->m_tabNomAlgo['MD5'])) $this->m_tabNomAlgo['MD5'] = FMK_HASH_EXTENSION_AUCUNE; if (!isset($this->m_tabNomAlgo['SHA1'])) $this->m_tabNomAlgo['SHA1'] = FMK_HASH_EXTENSION_AUCUNE; $this->m_tabNomAlgo['CKSUM8'] = FMK_HASH_EXTENSION_AUCUNE; $this->m_tabNomAlgo['CKSUM16'] = FMK_HASH_EXTENSION_AUCUNE; $this->m_tabNomAlgo['CKSUM32'] = FMK_HASH_EXTENSION_AUCUNE; $this->m_tabNomAlgo['CKSUM64'] = FMK_HASH_EXTENSION_AUCUNE; return count($this->m_tabNomAlgo)>0; } function F63a136aa($nIdAlgo) { $sNomAlgo = constant('eHA_ALGO_' . $nIdAlgo); $this->F0f610a15(''); if ( (utf8_strpos($sNomAlgo , 'TIGER') === 0) && isset($this->m_tabNomAlgo[$sNomAlgo.',3'])) { $sNomAlgo .= ',3'; } elseif ( ($sNomAlgo == 'TIGER192') && (!isset($this->m_tabNomAlgo[$sNomAlgo.',3']))) { $sNomAlgo = 'TIGER'; } return $sNomAlgo; } function F2c1ba61f($data = "", $width=192, $rounds = 3, $bAppelRecursif=true) { return ($bAppelRecursif) ? str_pad(bin2hex(strrev($data)), 16, '0') : substr( implode( array_map( array($this,__FUNCTION__), str_split(hash('tiger'.$width.','.$rounds, $data, true), 8) ) ), 0, 48-(192-$width)/4 ) ; } function F4f7161e3($nIdAlgo,$sNomAlgo,$sChaine,$sClef=null) { switch($this->m_tabNomAlgo[$sNomAlgo]) { case FMK_HASH_EXTENSION_MHASH: { if (!$this->Fcf4695d4($nIdAlgo)) $sHash = mhash(constant( 'MHASH_' . $sNomAlgo ),$sChaine); else $sHash = mhash(constant( 'MHASH_' . $sNomAlgo ),$sChaine,$sClef); } break; case FMK_HASH_EXTENSION_NATIVE_PHP5: { if (!$this->Fcf4695d4($nIdAlgo)) { if (PHPVERSION_HASH_TIGER_BUGENDIAN && strpos($sNomAlgo,'TIGER')===0) { $sHash = Fa9c2e9dc( $this->F2c1ba61f($sChaine,substr($sNomAlgo,strlen('TIGER'),3),$sNomAlgo[strlen($sNomAlgo)-1],false) ); } else { $sHash = hash($sNomAlgo, $sChaine, true); } } else { $sHash = hash_hmac($sNomAlgo, $sChaine, $sClef, true); } } break; case FMK_HASH_EXTENSION_AUCUNE: { $nTaille = utf8_strlen($sNomAlgo); if ( ($sNomAlgo == 'MD5') || ($sNomAlgo == 'SHA1') ) { if ((!$this->Fcf4695d4($nIdAlgo))) { if (PHPVERSION_5) { return call_user_func($sNomAlgo,$sChaine,true); } else { $sHashHexa = call_user_func($sNomAlgo,$sChaine); return Fa9c2e9dc($sHashHexa); } } else { return false; } } elseif (($nTaille>5) && (utf8_substr($sNomAlgo,0,5)=='CKSUM')) { return F226190d9($sChaine,intval(utf8_substr($sNomAlgo,5))); } else { $sHash = false; } } break; default: } return $sHash; } function Fcf4695d4($nIdAlgo) { return ($nIdAlgo >= 0x0100); } } $_FMK_CRYPT = null; function& FMK_CRYPT() { global $_FMK_CRYPT; if (!isset($_FMK_CRYPT)) $_FMK_CRYPT = new FMK_CRYPT(); return $_FMK_CRYPT; } function Fbd54c3d1($string) { if (!is_scalar($string)) { user_error('utf8_convert_uuencode() expects parameter 1 to be string, ' . gettype($string) . ' given', E_USER_WARNING); return false; } $u = 0; $encoded = ''; while (0!=($c = count($bytes = unpack('c*', utf8_substr($string, $u, 45))))) { $u += 45; $encoded .= pack('c', $c + 0x20); while ($c % 3) { $bytes[++$c] = 0; } foreach (array_chunk($bytes, 3) as $b) { $b0 = ($b[0] & 0xFC) >> 2; $b1 = (($b[0] & 0x03) << 4) + (($b[1] & 0xF0) >> 4); $b2 = (($b[1] & 0x0F) << 2) + (($b[2] & 0xC0) >> 6); $b3 = $b[2] & 0x3F; $b0 = $b0 ? $b0 + 0x20 : 0x60; $b1 = $b1 ? $b1 + 0x20 : 0x60; $b2 = $b2 ? $b2 + 0x20 : 0x60; $b3 = $b3 ? $b3 + 0x20 : 0x60; $encoded .= pack('c*', $b0, $b1, $b2, $b3); } $encoded .= "\n"; } $encoded .= "\x60\n"; return $encoded; } if (!function_exists('convert_uuencode')) { function convert_uuencode($string) { return Fbd54c3d1($string); } } function F4e6efab4($string) { if (!is_scalar($string)) { user_error('utf8_convert_uuencode() expects parameter 1 to be string, ' . gettype($string) . ' given', E_USER_WARNING); return false; } if (utf8_strlen($string) < 8) { user_error('utf8_convert_uuencode() The given parameter is not a valid uuencoded string', E_USER_WARNING); return false; } $decoded = ''; foreach (utf8_explode("\n", $string) as $line) { $c = count($bytes = unpack('c*', utf8_substr(utf8_trim($line,"\r\n\t"), 1))); while ($c % 4) { $bytes[++$c] = 0; } foreach (array_chunk($bytes, 4) as $b) { $b0 = $b[0] == 0x60 ? 0 : $b[0] - 0x20; $b1 = $b[1] == 0x60 ? 0 : $b[1] - 0x20; $b2 = $b[2] == 0x60 ? 0 : $b[2] - 0x20; $b3 = $b[3] == 0x60 ? 0 : $b[3] - 0x20; $b0 <<= 2; $b0 |= ($b1 >> 4) & 0x03; $b1 <<= 4; $b1 |= ($b2 >> 2) & 0x0F; $b2 <<= 6; $b2 |= $b3 & 0x3F; $decoded .= pack('c*', $b0, $b1, $b2); } } return utf8_rtrim($decoded, "\0"); } if (!function_exists('convert_uudecode')) { function convert_uudecode($string) { return F4e6efab4($string); } } class FMK_CRYPT extends FMK_CRYPTHASH { var $m_bEncrypt = true; var $m_sMotDePasse = ''; function Ff1e0c80b() { return 'ERR_CRYPT_BAD_CONSTANT_CRYPT'; } function Fcc87d15b() { $this->m_tabNomAlgo = array(); $pclDependance =& FMK_Dependance(); if ($pclDependance->F0b5f8f06('mcrypt')) { $tabAlgos = array_flip(mcrypt_list_algorithms()); if (array_key_exists(MCRYPT_BLOWFISH,$tabAlgos)) $this->m_tabNomAlgo[MCRYPT_BLOWFISH] = FMK_CRYPT_EXTENSION_MCRYPT; if (array_key_exists(MCRYPT_RIJNDAEL_128,$tabAlgos)) $this->m_tabNomAlgo[MCRYPT_RIJNDAEL_128] = FMK_CRYPT_EXTENSION_MCRYPT; } $this->m_tabNomAlgo[0] = FMK_CRYPT_EXTENSION_AUCUNE; $this->m_tabNomAlgo[3] = FMK_CRYPT_EXTENSION_AUCUNE; $this->m_tabNomAlgo[67108864] = FMK_CRYPT_EXTENSION_AUCUNE; return count($this->m_tabNomAlgo)>0; } function F63a136aa($nIdAlgo) { $sAlgo = $this->Fed8097e2($nIdAlgo); switch ($sAlgo) { case 1: return MCRYPT_BLOWFISH; case 2: return MCRYPT_RIJNDAEL_128; case 0: case 67108864: case 3: return 0; default: return $sAlgo; } } function F48147400($nIdAlgo) { switch ($nIdAlgo) { case 3: return MCRYPT_3DES; case 1: return MCRYPT_RIJNDAEL_128; case 2: return MCRYPT_DES; default: return $nIdAlgo; } } function F988988a3($nIdMode) { switch ($nIdMode) { case 2: return MCRYPT_MODE_CBC; case 1: return MCRYPT_MODE_ECB; default: return $nIdMode; } } function F4f7161e3($nIdAlgo,$sNomAlgo,$sChaine,$sClef=null) { if ($this->m_bEncrypt) { $sChaine = $this->F57173c08($nIdAlgo,$sNomAlgo,$sChaine,$sClef); if ($sChaine===false) return false; $sChaine = $this->Fe69f29c7($nIdAlgo,$sNomAlgo,$sChaine,$sClef); if ($sChaine===false) return false; $sChaine = $this->F641bf26b($nIdAlgo,$sNomAlgo,$sChaine,$sClef); if ($sChaine===false) return false; } else { $sChaine = $this->F641bf26b($nIdAlgo,$sNomAlgo,$sChaine,$sClef); if ($sChaine===false) return false; $sChaine = $this->Fe69f29c7($nIdAlgo,$sNomAlgo,$sChaine,$sClef); if ($sChaine===false) return false; $sChaine = $this->F57173c08($nIdAlgo,$sNomAlgo,$sChaine,$sClef); if ($sChaine===false) return false; } return $sChaine; } function F57173c08($nIdAlgo,$sNomAlgo,$sChaine,$sClef=null) { switch($this->m_tabNomAlgo[$sNomAlgo]) { case FMK_CRYPT_EXTENSION_MCRYPT: { if ($this->m_sMotDePasse === '' || $sChaine==='') return ''; $td = mcrypt_module_open($sNomAlgo, '', MCRYPT_MODE_ECB, ''); $is = mcrypt_enc_get_iv_size($td); $iv = mcrypt_create_iv($is, MCRYPT_RAND); $ks = mcrypt_enc_get_key_size($td); $key = $this->m_sMotDePasse; if (utf8_strlen($key) > $ks) { $key = utf8_substr($key,0,$ks); } mcrypt_generic_init($td, $key, $iv); $sCrypt = $this->m_bEncrypt ? mcrypt_generic( $td, $sChaine): utf8_trim(mdecrypt_generic( $td, $sChaine),utf8_chr(0)); mcrypt_generic_deinit($td); mcrypt_module_close($td); } break; case FMK_CRYPT_EXTENSION_AUCUNE: { if (0 === $sNomAlgo) { $sCrypt = $sChaine; } else { return false; } } break; default: return false; } return (string)$sCrypt; } function Fe69f29c7($nIdAlgo,$sNomAlgo,$sChaine,$sClef=null) { switch ($this->Fbed06c2f($nIdAlgo)) { case 65536: $sCompress = $sChaine; break; case 131072: $sCompress = $sChaine; break; case 0 : $sCompress = $sChaine; break; default: $this->m_pszErreur = 'ERR_CRYPT_BAD_CONSTANT_COMPRESSION'; return false; } return $sCompress; } function F641bf26b($nIdAlgo,$sNomAlgo,$sChaine,$sClef=null) { switch($sClef) { case 0: $sEncode = $sChaine; break; case 1: $sEncode = ''; if ($this->m_bEncrypt) { $this->F2a959281($sChaine,$sEncode,'64PCS'); } else { $this->F9c347e3c($sChaine,$sEncode,'64PCS'); } break; case 2: $sEncode = $this->m_bEncrypt ? base64_encode($sChaine) : base64_decode($sChaine); break; case 3: case 4: $sEncode = $this->m_bEncrypt ? utf8_convert_uuencode($sChaine) : utf8_convert_uudecode($sChaine); break; break; default: $this->m_pszErreur = 'ERR_CRYPT_BAD_CONSTANT_ENCODAGE'; return false; } return $sEncode; } function F2a959281($pbySource,&$pszDestination,$sEncodage='') { $pszDestination = ''; $nSize = utf8_strlen($pbySource); $nLineLength = 20; $sEncodage = '__CEncodeBase'.$sEncodage.'__cEncodeByte'; $nIndiceSource=$nIndiceDestination=$nRemaining=$nBloc=0; $byBuffer1=$byBuffer2=$byBuffer3 = null; for ($nIndiceSource=0,$nIndiceDestination=0;$nIndiceSource<$nSize;$nIndiceSource+=3) { $nRemaining=$nSize-$nIndiceSource; $byBuffer1=utf8_ord($pbySource[$nIndiceSource]); $byBuffer2=($nRemaining>1) ? utf8_ord($pbySource[$nIndiceSource+1]) : 0; $byBuffer3=($nRemaining>2) ? utf8_ord($pbySource[$nIndiceSource+2]) : 0; { $pszDestination.=$this->$sEncodage( (($byBuffer1 & 0xfc) >> 2) ); $pszDestination.=$this->$sEncodage( ( (($byBuffer1 & 0x03) << 4) | (($byBuffer2 & 0xf0) >> 4) )); if ($nRemaining>1) $pszDestination.=$this->$sEncodage( ( (($byBuffer2 & 0x0f) << 2) | (($byBuffer3 & 0xc0) >> 6) )); else break; if ($nRemaining>2) $pszDestination.=$this->$sEncodage( ( $byBuffer3 & 0x3f )); else break; } if ((++$nBloc)%$nLineLength==0) { { $pszDestination.="\r\n"; } } } } function __CEncodeBase64PCS__cEncodeByte($b) { if ($b<=25) return utf8_chr(utf8_ord('A')+$b); if (($b>=26) && ($b<=51)) return utf8_chr(utf8_ord('a')+$b-26); if (($b>=52) && ($b<=61)) return utf8_chr(utf8_ord('0')+$b-52); if ($b==62) return '+'; return '/'; } function F9c347e3c($pszSource,&$pbyDestination,$sDecodage='') { $pbyDestination = ''; $sDecodage = '__CEncodeBase'.$sDecodage.'__byDecodeChar'; $nIndiceSource=$nIndiceDestination=$nRemaining=$nSize=utf8_strlen($pszSource); $byBuffer1=$byBuffer2=$byBuffer3=$byBuffer4 = null; for ($nIndiceSource=0,$nIndiceDestination=0;$nIndiceSource<$nSize;$nIndiceSource+=4) { $nRemaining=$nSize-$nIndiceSource; if (utf8_substr($pszSource,$nIndiceSource,1)==="\n" || utf8_substr($pszSource,$nIndiceSource,1)==="\r") { $nIndiceSource-=3; continue; } $byBuffer1=$this->$sDecodage($pszSource[$nIndiceSource ]); $byBuffer2=($nRemaining>1) ? $this->$sDecodage($pszSource[$nIndiceSource+1]) : 0; $byBuffer3=($nRemaining>2) ? $this->$sDecodage($pszSource[$nIndiceSource+2]) : 0; $byBuffer4=($nRemaining>3) ? $this->$sDecodage($pszSource[$nIndiceSource+3]) : 0; { if ($nRemaining>1) $pbyDestination.=utf8_chr( ($byBuffer1 << 2) | (($byBuffer2 & 0x30) >> 4) ); else break; if ($nRemaining>2) $pbyDestination.=utf8_chr( (($byBuffer2 & 0x0f) << 4) | (($byBuffer3 & 0x3c) >> 2) ); else break; if ($nRemaining>3) $pbyDestination.=utf8_chr( (($byBuffer3 & 0x03) << 6 ) | ($byBuffer4 & 0x3f) ); else break; } } } function __CEncodeBase64PCS__byDecodeChar($c) { $c = utf8_ord($c); if (($c>=utf8_ord('A')) && ($c<=utf8_ord('Z'))) return ($c-utf8_ord('A')); if (($c>=utf8_ord('a')) && ($c<=utf8_ord('z'))) return ($c-utf8_ord('a')+26); if (($c>=utf8_ord('0')) && ($c<=utf8_ord('9'))) return ($c-utf8_ord('0')+52); if ($c===utf8_ord('+')) return 62; return 63; } function Fed8097e2($nIdAlgo) { $nRet = 0xffff & ($nIdAlgo); return $nRet; } function Fbed06c2f($nIdAlgo) { $nIdAlgo &= ~67108864; $nRet = 0xffff & ($nIdAlgo >> 16); return $nRet; } function F9c5ce817($nIdAlgo,$sChaine,$sClef=null) { $this->m_bEncrypt = false; $sRetour = $this->Fb4468e0c($nIdAlgo,$sChaine,$sClef); $this->m_bEncrypt = true; return $sRetour; } } ?>